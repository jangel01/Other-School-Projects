#
# CPSC 323 Parser Project
# Author: Jason Angel
# Your task is to implement a parser using the default grammar
# parser csv table generated by the Java program.
#

import csv


class Parser:
    """
    This class parses the token stream outputted from the lexical analyzer
    into a parse tree or produces errors if the program is malformed.
    """

    def __init__(self, token_stream, parse_table_file):
        """
        Class constructor takes the token stream output from the
        lexical analyzer as input. Appends $ to the end of the stream.
        """
        self.parse_table_dict = {}
        self.parser_stack = ['E', 0]
        self.step = 1
        self.token_stream = token_stream
        self.parser_table = self.__read_parse_table(parse_table_file)
        # Append the end of file symbol to the end.
        self.token_stream.append(("$", "$"))

    def __read_parse_table(self, parse_table_file):
        """
        Reads the parse table from a file.
        @param parse_table_file The file path for the parse table csv file.
        @return A dictionary/map (state, symbol) -> action/goto.
        """

        with open(parse_table_file, 'r') as file:
            parse_table_reader = csv.reader(file)

            symbols = ["$", "id", "+", "=", "S", "E"]
            next(file)

            for state_num, row in enumerate(parse_table_reader):
                for col in range(1, len(symbols) + 1):
                    temp_tuple = (state_num, symbols[col - 1])

                    self.parse_table_dict[temp_tuple] = row[col]

    def printInfo(self, x):
      """ Print the current stack, input, and action in a single line"""

      print(str(self.step) + ".", end=" ")

      for s in range(len(self.parser_stack)):
        if s == len(self.parser_stack) - 1:
          print(self.parser_stack[s], end=" | ")
        else:
          print(self.parser_stack[s], end="")


      for i in range(len(self.token_stream)):
        if i == len(self.token_stream) - 1:
          print(self.token_stream[i][1], end=" | ")
        else:
          print(self.token_stream[i][1], end=" ")

      if x == "ACCT":
        print("ACCT")
      elif x[0] == 'S':
        print("Shift")
      elif x[0] == 'R':
        print("Reduce")

    def parse(self):
      """ Parse input from token stream."""

      """
        Grammar:
        1. S -> E + E
        2. S -> id
        3. E -> E + id
        4. E -> id
        nonterminals: id + =
      """

      # chronlogical production size and nonterminal symbol
      production = [(3, 'S'), (1, 'S'), (3, 'E'), (1, 'E')]

      print("The stack, input, and action for each step are shown from left to right respectively.")

      while 1:
        qn = self.parser_stack[-1]
        i = self.token_stream[0][1]

        x = self.parse_table_dict.get((int(qn), str(i)))

        if x[0] == 'S': # SHIFT OPERATION
          self.printInfo(x)
          self.step += 1

          # Push leftmost symbol of the input to the front of the stack.
          self.parser_stack.append(i)

          # Push shift # to the front of the stack
          if len(x) == 3:
            self.parser_stack.append(x[1] + x[2])
          else:
            self.parser_stack.append(x[1])

          # Delete leftmost symbol from token stream
          del self.token_stream[0]

        elif x[0] == 'R': # REDUCTION OPERATION
          self.printInfo(x)
          self.step += 1

          # Pop off 2x symbols of RHS_production
          symbols_to_remove = 2 * production[int(x[1]) - 1][0]
          for n in range(symbols_to_remove):
            self.parser_stack.pop()

          # Grab LHS nonterminal from production
          nonterminal = production[int(x[1]) - 1][1]
          # Grab state number
          qj = self.parser_stack[-1]

          # Push LHS nonterminal and state number derived from the lookup [qj, E] respectively
          self.parser_stack.append(nonterminal)
          self.parser_stack.append(self.parse_table_dict.get((int(qj), str(nonterminal))))

        elif x == "ACCT":
          self.printInfo(x)
          break
        else:
          print(f'Token : {self.token_stream[0][1]} Lexeme: {self.token_stream[0][0]} rejected.')
          print(f'Step : {self.step}; {qn} amd {i} lead to an empty cell.')
          print("Accepted tokens: +, =, id")
          exit(0)
